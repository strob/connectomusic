<html>
  <head>
    <title>instrument</title>
    <script src="jquery.js"></script>
    <style>
body {
  background-color: white;
  margin: 0;
  padding: 0;
}
.node {
  position: absolute;
  z-index: 10;
  width: 10;
  height: 10;
  cursor: pointer;
}
.node:hover,.node.playing {
  background-color: yellow;
}
#base, #overlay {
  position: absolute;
}
#toolbar {
  position: fixed;
  top: 35px;
  right: 10px;
}
.button, .toggle, .option {
  cursor: pointer;
  margin: 10px;
}
.knob {
  margin: 10px;
  cursor: ns-resize;
}
    </style>
  </head>
  <body>
    <script>
var EDGE = function(a, b, id) {
    this.a = a;
    this.b = b;
    this.id = id;
    this.length = Math.sqrt(
        Math.pow(a.pt[0] - b.pt[0], 2) + 
        Math.pow(a.pt[1] - b.pt[1], 2));
};

var EdgeState = function(edge) {
    this.edge = edge;
    this.percentage = 0.0;
};
EdgeState.prototype.iterate = function(t, speed) {
    var npixels = t * speed;
    var dpercentage = npixels / this.edge.length;

    this.percentage += dpercentage;
    if(this.percentage > 1.0) {
        return true;
    }
    return false;
};
EdgeState.prototype.get_position = function() {
    var that = this;
    return [0, 1].map(function(X) {
        return that.edge.a.pt[X] + that.percentage*(that.edge.b.pt[X] - that.edge.a.pt[X]);
    });
};

 var GRAPH = function(spec) {
    var that = this;

     // user-controllable parameters
     this.params = {
         speed: 0.3,
         target: 0.1,
         sounds: "s2",
         mode: "down",
         net: false
     };
     this.SPEED_MAX = 250;
     this.TARGET_MAX = 100;

    this.nodes = spec.nodes;
    this._edgespec = spec.edges;

    this.W = 1200;
    this.H = 1240;

    this.$el = $("<div>");

    this.$canvas = $("<canvas>", {id: "base"})
        .attr({width: this.W,
              height:this.H})
        .appendTo(this.$el);
    this.$overlay = $("<canvas>", {id: "overlay"})
        .attr({width: this.W,
               height:this.H})
         .appendTo(this.$el);

    this.state_edges = [];
     this.nplaying = 0;

     this.clearburn();
     this.load_sounds();

     // Start a timer to manage edges
     var T = 0.1;               // seconds
     this.edgeinterval = window.setInterval(function() {
         // Clear overlays
         that.$overlay
             .attr({width: that.W,
                    height:that.H})

         // ...and update
         var ctx = that.$overlay[0].getContext('2d');

         // burns
        if(that.params.mode === "burnbridges") {
            ctx.strokeStyle = "red";
            ctx.beginPath();
            for(var key in that._edgeburn) {
                var e = that._edgeburn[key];
                ctx.moveTo(e.a.pt[0], e.a.pt[1]);
                ctx.lineTo(e.b.pt[0], e.b.pt[1]);
            }
            ctx.stroke();
        }
         ctx.strokeStyle = "cyan";
         ctx.beginPath();

         that.state_edges.forEach(function(edgestate, idx) {
             if(edgestate.iterate(T, that.params.speed*that.SPEED_MAX)) {
                 // Remove edge & trigger
                 // XXX: will "idx" be correct on the next iteration?
                 that.state_edges.splice(idx, 1);
                 // XXX: check against TARGET
                 that.trigger(edgestate.edge.b);

                 if(that.params.mode === "burnbridges") {
                     that._edgeburn[edgestate.edge.id] = edgestate.edge;
                 }

             }
             else {
                 ctx.moveTo(edgestate.edge.a.pt[0], edgestate.edge.a.pt[1]);
                 var pos = edgestate.get_position();
                 ctx.lineTo(pos[0], pos[1]);
             }
         });

         ctx.stroke();

     }, 1000*T);

    this.$nodes = [];

    this.nodes.forEach(function(node, idx) {
        // Add "id" to each node; used as key in "this.edges"
        node.id = idx;

        var $node = $("<div>")
            .addClass('node')
            .offset({left: node.pt[0]-5,
                     top: node.pt[1]-5})
            .click(function() {
                that.trigger(node);
                that.ontrigger(idx);
            })
            .appendTo(that.$el);
        that.$nodes.push($node);
    });

    this.compute_edges();
    this.draw_base();

};
GRAPH.prototype.ontrigger = function(nid) {
    // (Unimplemented) callback on *user-initiated* playback events.
    console.log("shouldn't be here");
};
GRAPH.prototype.clearburn = function() {
    this._edgeburn = {};       // id: edge
    this._nodeburn = {};       // id: node
};
GRAPH.prototype.trigger = function(node) {
    var that = this;

    // Only trigger if we're below target
    if(this.nplaying >= (this.TARGET_MAX * this.params.target) || (node.id in this._nodeburn)) {
        return;
    }
    this.nplaying += 1;

    var a = that.get_sound(node.nedges);
    var $node = that.$nodes[node.id];
    $node.addClass('playing');
    a.ontimeupdate = function() {
        var percent = a.currentTime / a.duration;
        $node
            .css({width: 10*(1-percent),
                  height:10*(1-percent)})
            .offset({left: node.pt[0]-5*(1-percent),
                     top: node.pt[1]-5*(1-percent)});
    };
    a.onended = function() {    // XXX: 'bind'/'unbind'?
        that.nplaying -= 1;

        if(that.params.mode === "burnbridges") {
            that._nodeburn[node.id] = node;
        }

        $node.removeClass('playing')
            .css({width: 10,
                  height:10})
            .offset({left: node.pt[0]-5,
                     top: node.pt[1]-5});

        (that.edges[node.id] || []).forEach(function(edge) {
            if(!(edge.id in that._edgeburn)) {
                that.state_edges.push(new EdgeState(edge));
            }
        });
    };
    a.play();

};
GRAPH.prototype.compute_edges = function() {
    var that = this;

    var BD = (this.params.mode === "burnbridges" || this.params.mode === "bidir");
    var UP = this.params.mode === "up";

    this.edges = {};
    this._edgespec.forEach(function(e, idx) {
        var a = that.nodes[e.a];
        var b = that.nodes[e.b];
        
        if(BD) {
            // Since these are the same edge in different directions,
            // the index is the same.
            _append(that.edges, a.id, new EDGE(a, b, idx));
            _append(that.edges, b.id, new EDGE(b, a, idx));
        }
        else {
            if((a.nedges < b.nedges && !UP) || (a.nedges > b.nedges && UP)) {
                // swap a and b
                var c = b;
                b = a;
                a = c;
            }
            _append(that.edges, a.id, new EDGE(a, b, idx));
        }
    });

};
GRAPH.prototype.draw_base = function() {
    var that = this;
    var ctx = this.$canvas[0].getContext('2d');
    ctx.strokeStyle = "#000";
    ctx.beginPath();
    for(var k in this.edges) {
        this.edges[k].forEach(function(edge) {
            var a = edge.a;
            var b = edge.b;
            ctx.moveTo(a.pt[0], a.pt[1]);
            ctx.lineTo(b.pt[0], b.pt[1]);
        })
    }
    ctx.stroke();
};
GRAPH.prototype.load_sounds = function() {
    var that = this;
    $.getJSON(this.params.sounds + '.json', {}, function(snd) {
        that.set_sounds(snd);
    });
};
GRAPH.prototype.set_sounds = function(snds) {
    this.sounds = {};
    for (var key in snds) {
        this.sounds[key] = snds[key].map(function(x) {
            var a = new Audio(x + '.ogg'); // XXX: or mp3!
            a.load();
            a.onload = function() {
                // XXX: Update visualization (?)
                console.log("Loaded!", x);
            }
            return a;
        });
    }
};
GRAPH.prototype.get_sound = function(n) {
    if(!(n in this.sounds)) {
        console.log('no sound for n', n);
        n = 19;
    }
    var out = this.sounds[n][0];
    this.sounds[n] = this.sounds[n].slice(1).concat([out]);
    return out;
};

var TOOLBAR = function(graph) {
    var that = this;
    this.g = graph;
    this.$el = $("<div>", {id: "toolbar"});

    this.g.ontrigger = function(nid) {
        if(that.LIVE) {
            console.log("send", nid);
            that.LIVE.send(JSON.stringify({type: "trigger", nid: nid}));
        }
    }

    var bar = [
        {type: "select",
         name: "mode",
         options: ["down", "up", "bidir", "burnbridges"]},

        {type: "knob",
         name: "speed",
         min: 0,
         max: 250},

        {type: "knob",
         name: "target",
         min: 0,
         max: 100},

        {type: "buttongroup",
         buttons: ["saturate", "panic"]},

        {type: "toggle",
         name: "net"}
    ];

    var icon = function(name) {
        return "icon/" + name + ".png";
    }
    this.icon = icon;
    var icon_on = function(name) {
        return "icon/" + name + "_on.png";
    }
    this.icon_on = icon_on;

    var ux = function(x) {
        var $el;

        switch(x.type) {
        case "select" :
            $el = $("<div>")
                .addClass(x.name);
            x.options.forEach(function(opt) {
                $("<img>", {src: (that.g.params.mode === opt) ? icon_on(opt) : icon(opt)})
                    .addClass("option")
                    .addClass(opt)
                    .data("name", opt)
                    .appendTo($el)
                    .click(function() {
                        that.set(x.name, opt);
                    })
            });
            that.set(x.name, that.g.params[x.name]);

            break;
        case "toggle" :
            $el = $("<img>", {src: icon(x.name)})
                .addClass("toggle")
                .data("on", false)
                .click(function() {
                    that.toggle(x.name);
                });

            break;
        case "buttongroup" :
            $el = $("<div>").addClass("buttongroup");
            x.buttons.forEach(function(button) {
                $("<img>", {src: icon(button)})
                    .addClass("button")
                    .mouseover(function() {this.src = icon_on(button);})
                    .mouseout(function() {this.src = icon(button);})
                    .click(function() {
                        console.log(button);

                        if(that.LIVE) {
                            that.LIVE.send(JSON.stringify({type: "press",
                                                           button: button}));
                        }

                        if(that["on"+button]) {
                            that["on"+button]();
                        }
                    })
                    .appendTo($el);
            });
            break;
        case "knob" :
            $el = $("<canvas>")
                .addClass("knob")
                .addClass(x.name)
                .data("val", 0.5);
            (function($can) {
                var $img = $("<img>", {src: icon(x.name)})
                    .load(function() {
                        $can.attr({width: this.width,
                                   height: this.height});
                        $can.data("w", this.width);
                        $can.data("h", this.height);
                        $can.data("cx", this.width / 2);
                        $can.data("cy", 16); // hardcoded...
                        $can.data("r", 16);
                        $can.data("img", this);
                        var ctx = $can[0].getContext('2d');
                        ctx.drawImage(this, 0, 0);

                        that.turnKnob(x.name, that.g.params[x.name]); // initialize

                        $can.mousedown(function(ev) {
                            ev.preventDefault();
                            // start drag
                            var px = ev.clientX;
                            var py = ev.clientY;
                            window.onmousemove = function(ev) {
                                var dx = ev.clientX - px;
                                var dy = ev.clientY - py;

                                var val = $can.data("val");
                                val = Math.min(1, Math.max(0, val + dy / 100));
                                $can.data("val", val);

                                that.set(x.name, val);

                                px = ev.clientX;
                                py = ev.clientY;
                            }
                            window.onmouseup = function() {
                                // stop drag
                                window.onmousemove = undefined;
                                window.onmouseup = undefined;
                            }
                        });
                    });
            })($el)
            break;
        }
        return $el;
    }

    bar.forEach(function(b) {
        that.$el.append(ux(b));
    });
}
TOOLBAR.prototype.set = function(k, v, nobubble) {
    // update graph
    var old = this.g.params[k];
    if(old === v) {
        // no change
        return;
    }
    this.g.params[k] = v;

    if(this["on"+k]) {
        this["on"+k](v);
    }

    if(this.LIVE && !nobubble && k != "net") {
        this.LIVE.send(JSON.stringify({type: "set", key: k, value: v}));
    }
};
TOOLBAR.prototype.toggle = function(k) {
    this.set(k, !this.g.params[k]);
};
TOOLBAR.prototype.onmode = function(v) {
    var that = this;
    this.$el.find(".mode .option").each(function(idx, opt) {
        if($(opt).data("name") === v) {
            opt.src = that.icon_on(v);
        }
        else {
            opt.src = that.icon($(opt).data("name"));
        }
    });
    // XXX: not always!
    this.g.clearburn();
    this.g.compute_edges();
};
TOOLBAR.prototype.onnet = function(net) {
    var that = this;
    if(net) {
        var url = "ws://" + window.location.hostname + ":8124";
        this.LIVE = new WebSocket(url);
        this.LIVE.onmessage = function(msg) {
            // console.log("MSG", msg);
            var msg = JSON.parse(msg.data);
            if(msg.type === "trigger") {
                // simulate graph click
                console.log("recv'd click", msg.nid, that.g.nodes[msg.nid]);
                that.g.trigger(that.g.nodes[msg.nid]);
            }
            else if(msg.type === "press") {
                console.log("recv'd button", msg.button);
                that["on"+msg.button]();
            }
            else if(msg.type ==="set") {
                console.log("recv'd param", msg.key, msg.value);
                that.set(msg.key, msg.value, true);
            }
            else if(msg.type === "reset") {
                console.log("reset from server", msg);
                for(var key in msg.params) {
                    that.set(key, msg.params[key], true);
                }
            }
            else {
                console.log("unknown message", msg);
            }
        }
    }
    else {
        // XXX: how to properly disconnect?
        console.log("LIVE", this.LIVE);
        this.LIVE.close();
        this.LIVE = undefined;
    }

    this.$el.find(".toggle")
        .attr("src", net ? this.icon_on("net") : this.icon("net"));
};
TOOLBAR.prototype.onsaturate = function() {
    for(var i=0; i< (this.g.params.target * this.g.TARGET_MAX); i++) {
        var nid = Math.floor(Math.random() * this.g.nodes.length);
        this.g.trigger(this.g.nodes[nid]);
    }
};
TOOLBAR.prototype.onpanic = function() {
    this.g.state_edges = [];
    for(var key in this.g.sounds) {
        this.g.sounds[key].forEach(function(a) {
            a.pause();
            a.currentTime = 0.0;
        });
    }
    $(".node")
        .removeClass("playing");
    this.g.clearburn();
    this.g.nplaying = 0;
};
TOOLBAR.prototype.turnKnob = function(name, val) {
    var $can = this.$el.find(".knob."+name);
    $can.data("val", val);
    // redraw
    $can.attr({width: $can.data("w"),
               height: $can.data("h")});
    var ctx = $can[0].getContext('2d');
    ctx.drawImage($can.data("img"), 0, 0);
    ctx.strokeStyle = "red";
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo($can.data("cx"), $can.data("cy"));
    var pad = 0.1;
    var theta = $can.data("val")*2*Math.PI*(1-pad) - Math.PI/2;
    var lx = $can.data("cx") + $can.data("r") * Math.cos(theta);
    var ly = $can.data("cy") + $can.data("r") * Math.sin(theta);
    ctx.lineTo(lx, ly);
    ctx.stroke();
};
TOOLBAR.prototype.onspeed = function(val) {
    this.turnKnob("speed", val);
};
TOOLBAR.prototype.ontarget = function(val) {
    this.turnKnob("target", val);
};

        // UTILITY

function _append(d, k, v) {
    // Make or add to list
    if(d[k] === undefined) {
        d[k] = [];
    }
    d[k].push(v);
}

        // STARTUP
var g;
$.getJSON('graph.json', {}, function(res) {
    g = new GRAPH(res);
    t = new TOOLBAR(g);
    $("body")
        .append(g.$el)
        .append(t.$el);
});

    </script>
  </body>
</html>
